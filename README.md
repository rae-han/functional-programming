## **9장: 웹 크롤러 설계**

## **핵심 내용 상세 요약**

- **문제 정의 및 요구사항**
  - 웹 크롤러는 주어진 URL 집합에서 웹페이지를 다운로드하고, 그 안의 링크를 추출해 다시 크롤링하는 과정을 반복한다.
  - 크롤링 대상(HTML만, 이미지/문서 포함 여부), 크롤링 규모, 중복 페이지 처리, 최신 페이지 반영, 데이터 저장 기간 등 요구사항을 명확히 해야 한다.
- **아키텍처 및 주요 컴포넌트**
  - **URL Frontier:** 아직 방문하지 않은 URL 목록을 큐로 관리한다. 대규모 시스템에서는 분산 큐를 사용해 확장성을 확보한다.
  - **Downloader:** 큐에서 URL을 꺼내 실제 웹페이지를 다운로드한다.
  - **Parser:** HTML에서 새로운 링크를 추출하고, 필요한 데이터(예: 텍스트, 메타데이터 등)를 파싱한다.
  - **Duplicate Eliminator:** 해시 함수 등을 이용해 이미 방문한 URL이나 중복 콘텐츠를 걸러낸다.
  - **Scheduler:** 크롤링 우선순위, 속도 제한, robots.txt 준수 등 정책을 관리한다.
    - → 페이지 랭크 주로 링크의 수, 품질을 기반으로 산정
- **확장성과 신뢰성**
  - 수많은 페이지를 병렬로 처리할 수 있도록 분산 시스템 구조를 도입한다.
  - 장애(다운로드 실패, 무한 루프 등) 발생 시 재시도 및 예외 처리가 필요하다.
  - robots.txt, IP 차단 등 크롤러가 예절을 지키도록 설계해야 한다.

## **스터디에서 말할만한 포인트 해설**

- **병렬/분산 처리의 필요성:**
  대규모 크롤링에서는 단일 서버로는 처리량이 부족하므로, 여러 서버가 URL Frontier를 공유하거나 분산 큐를 통해 작업을 분산해야 한다.
  → 실제로 구글, 네이버 등은 수백~수천 대의 크롤러 서버를 운영한다.
- **크롤러 예절(Politeness):**
  robots.txt 파일을 읽어 사이트 정책을 준수하고, 도메인별로 요청 속도를 제한해야 한다.
  → 무분별한 크롤링은 서비스 차단(IP 블록) 등 문제를 유발할 수 있다.
  → 호스트별 워커스레드 할당에 동시요청 X
  → Distributed DOS, 크롤러는 DOS
- 우선순위
  → 페이지 랭크 주로 링크의 수, 품질을 기반으로 산정
- **중복/무한루프 방지:**
  이미 방문한 URL은 해시 테이블 등으로 관리하며, 유사 콘텐츠 판별(해시, 시그니처)도 필요하다.
- **실패/장애 대응:**
  네트워크 오류, 잘못된 HTML, 서버 다운 등 다양한 장애 상황에서 재시도, 로그 기록, 모니터링이 필수이다.
- **대용량 데이터 관리:**
  수십억~수조 개 URL/페이지를 저장하려면 효율적인 데이터베이스 설계와 캐싱 전략이 필요하다.
- 서버 측 렌더링
  페이지 파싱 전 서버측 렌더링

## **10장: 알림 시스템 설계**

## **핵심 내용 상세 요약**

- **문제 정의 및 요구사항**
  - 알림은 푸시(iOS/Android), SMS, 이메일 등 다양한 형태가 있다.
  - 실시간/지연 허용, 대량 발송, 사용자의 수신 거부(opt-out) 등 요구사항을 파악해야 한다.
- **아키텍처 및 주요 컴포넌트**
  - **Notification Server:** 모든 알림 요청을 받아 공통 인터페이스로 처리하며, 외부 서비스(APNS, FCM, SMS, 이메일 등)에 전달한다.
  - **DB/Cache:** 사용자 정보, 디바이스 토큰, 알림 템플릿, 수신 설정 등을 저장한다.
  - **Message Queue:** 대량 알림 처리, 시스템 decoupling, 장애 시 버퍼 역할을 한다.
  - **Worker:** 큐에서 알림 이벤트를 꺼내 실제 전송 작업을 수행한다.
  - **Rate Limiter/Retry/Analytics:** 과도한 알림 방지, 실패 시 재시도, 알림 도달률/열람률 분석 등 부가 기능을 갖춘다.
- **확장성과 신뢰성**
  - 서버/워크 수평 확장, 메시지 큐로 병목 해소, SPOF(단일 장애점) 제거.
  - 알림 유실 방지(재시도, 로그), 사용자별 알림 환경 설정, 보안(토큰, 인증) 등 고려.

## **스터디에서 말할만한 포인트 해설**

- **비동기 처리와 메시지 큐의 장점:**
  대량 알림을 실시간으로 처리할 때, 큐를 통해 서버 부하를 분산하고 장애 시 데이터 유실을 막을 수 있다.
- 안정성
  - 알림로그 데이터베이스
    → 아웃박스 패턴
    → 단점: 중복가능, 순서 보장 안됨, 복잡성 높음
- **알림 채널별 특성:**
  푸시, SMS, 이메일은 각각 전송 속도, 비용, 신뢰성, 도달률이 다르다.
  예) SMS는 비용이 높고, 푸시는 무료지만 앱 설치가 필요하다.
- **사용자별 알림 설정/구독 관리:**
  사용자가 알림 종류별로 수신 여부를 선택할 수 있도록 세분화된 설정이 필요하다.
- **알림 유실/중복 방지:**
  알림 전송 실패 시 재시도 로직, 중복 전송 방지(알림 ID deduplication) 설계가 중요하다.
- **모니터링 및 분석:**
  알림 발송 성공률, 오픈/클릭률 등 지표를 수집해 서비스 품질을 개선한다.

## **11장: 뉴스피드 시스템 설계**

## **핵심 내용 상세 요약**

- **문제 정의 및 요구사항**
  - 사용자의 친구/팔로우한 사람들의 게시글을 시간순 또는 알고리즘 순으로 보여주는 시스템이다.
  - 모바일/웹 지원, 최대 친구 수, 미디어 지원, 대규모 트래픽 등 요구사항을 파악한다.
- **아키텍처 및 주요 컴포넌트**
  - **Feed Publishing API:** 사용자가 게시글을 올릴 때 호출, 게시글 DB/캐시에 저장, 친구들의 피드에 반영.
  - **Fanout Service:**
    - **Push 모델(Write 시 Fanout):** 게시글을 친구들의 피드에 즉시 반영(읽기 속도 빠름).
    - **Pull 모델(Read 시 Fanout):** 사용자가 피드를 볼 때마다 최신 게시글을 모아서 제공(자원 절약).
    - **Hybrid:** 일반 유저는 Push, 유명인/팔로워 많은 유저는 Pull 혼합 적용.
  - **Newsfeed Cache:** 각 사용자별 피드 목록을 캐시에 저장, 빠른 조회 지원.
  - **Post/Media Cache, CDN:** 게시글/미디어 파일을 별도 캐시, CDN으로 분산 저장.
  - **DB 확장:** 샤딩, 복제, NoSQL/SQL 혼합, 수평 확장 등.
- **확장성과 신뢰성**
  - 무상태 웹 계층, 메시지 큐로 컴포넌트 결합도 낮추기, 다중 데이터센터, 모니터링 등.

## **스터디에서 말할만한 포인트 해설**

- **Push vs Pull(Write/Read Fanout) 장단점:**
  - Push: 읽기는 빠르지만, 팔로워 많은 유저(셀럽) 게시 시 부하 집중, 비활성 사용자에도 불필요한 연산 발생.
  - Pull: 자원 절약, 비활성 사용자엔 연산 안 함. 대신 읽기 시점에 부하 집중, 실시간성이 떨어질 수 있음.
  - Hybrid: 트래픽, 사용자 유형에 따라 혼합 적용.
- **친구 수가 많은 사용자(셀럽) 대응:**
  팔로워 수가 많은 사용자는 Pull로 처리, 일반 사용자는 Push로 처리해 Hot Key 문제 완화.
- **데이터베이스 샤딩/캐싱:**
  대용량 데이터 분산 저장, 읽기/쓰기 분리, 캐시 활용으로 성능 개선.
  메모리 기반 캐시
  - 핫 캐시(메모리)
  - 웜 캐시(중간 정도는 SSD)
  - 콜드 캐시(덜 인기 있는건 HDD)
    CDN
  - 압축
  - 동적 캐시 크기 조정(피크 시간에 확장)
    분산 캐시 시스템
- **무상태 웹 서버/메시지 큐:**
  서버 장애 시에도 서비스 연속성 확보, 컴포넌트 간 결합도 낮추기.
- **피드 정렬/추천 알고리즘:**
  단순 시간순 외에도 개인화 추천, 우선순위 정렬 등 다양한 전략 적용 가능.
- **모니터링/지표:**
  QPS, 피드 로딩 지연, 캐시 적중률 등 주요 지표 모니터링으로 시스템 안정성 확보

## **스터디 토론에 적합한 심화 질문/주제**

- **크롤러/알림/피드 시스템에서 확장성과 신뢰성 확보 방법 비교**
- **메시지 큐, 캐시, 샤딩 등 분산 시스템 설계 요소의 실제 적용 사례와 장단점**
- **Push와 Pull 모델의 트레이드오프와 실제 서비스 적용 경험**
- **알림/피드 시스템에서 사용자 맞춤화(개인화) 설계 방법**
- **대규모 장애(서버 다운, 데이터 유실 등) 발생 시 복구 전략**
- **모니터링, 로그, 지표 수집의 중요성과 구체적 방법**
- **현업에서 사용하는 오픈소스/클라우드 솔루션(예: Kafka, Redis, AWS SQS 등) 활용 경험 공유**
- **시스템 설계 면접에서 요구사항 명확화, 트레이드오프 설명, 확장성/신뢰성 강조의 중요성**

> 각 장별로 실제 시스템 설계에서 고려해야 할 세부 요소와, 스터디에서 토론할 수 있는 심층 포인트를 상세히 설명했다. 실무 경험이나 실제 사례와 연결하여 논의하면 더욱 풍부한 스터디가 될 수 있다.
